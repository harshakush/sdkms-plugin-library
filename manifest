[
    {
        "name": "DUKPT", 
        "versions": {
            "1.0": {
                "path": "dukpt/plugin.lua", 
                "description": "## Short Description\nPlugin for importing DUKPT BDKs and for encrypting and decrypting data using the DUKPT procedure.\n### ## Introduction\nDUKPT plugin is an SDKMS implementation of the Derived Unique Key Per Transaction process that's described in Annex A of ANS X9.24-2009. This module provides DUKPT decryption using the 3DES scheme. It decrypts the encrypted card information using the KSN and BDK-ID as inputs to the plugin and generates decrypted/plain card information.\n\nInitially there is a Base Derivation Key (BDK) that is used to generate the \"Initial PIN Encryption Key\" (IPEK). The BDK always stays in the HSM and is never injected into the devices. It is known only by the manufacturer and the merchant. The \"Key Serial Number\" (KSN) and IPEK are injected into each device. The KSN is sent with the \"crypt\" material so that the receiving end can also decrypt it. The last 21 bits of the KSN are a counter that gets incremented every transaction.\n\nThere is a single DUKPT plugin, with three supported operations: `import`, `encrypt`, and `decrypt`.\n\n## Use Cases\nAs described above in the Introduction, the value of DUKPT is the ability to secure many independent messages in such a way that compromising the keys for any individual message doesn't endanger other messages while still minimizing the number of keys that need to be stored and managed. The canonical example of\nthis, and the use case for which this procedure was developed, is to encrypt payment information during transactions.\n\n## Setup\n### Using SDKMS Plugins\n* Plugins are an independent and secure subsystem where business logic can be\nexecuted inside SDKMS.\n* Plugins are invoked using a REST API similar to the cryptographic and key\nmanagement APIs.\n* Plugins are identified by UUID, like apps and security objects.\n* To invoke a plugin, make a POST request to `https://<API endpoint>/sys/v1/plugins/<uuid>`.\nThe POST request body must be either valid\nJSON or empty. The exact structure is defined by the plugin.\n* The request may return:\n- 200 OK with a JSON response body,\n- 204 No Content with empty response body, or\n- a 4xx/5xx error with a plain text error message response body.\n\n### Invoking SDKMS plugins from SDKMS Python CLI\nCheck the SDKMS CLI README for information on setting up the CLI.\n\nLogin to sdkms inorder to invoke plugin:\n\n`$ sdkms-cli user-login`\n\nTo invoke a plugin:\n\n`$ sdkms-cli invoke-plugin --name dukpt --in <decrypt-in.json>`\n\n* Plugins can either be invoked using `--name` or `--id`, taking the plugin's name or UUID respectively.\n* `in` : Path to input json file.\n\n## DUKPT Input/Output JSON Formats\nThe following sections specify the fields in the inputs and outputs of the plugin's operations, which are JSON maps.\n\n### DUKPT Import Operation\n#### Input\n* `operation` : Must be the string `import` for importing BDKs.\n* `name` : A string to be used as the name of the key in SDKMS. Must be unique.\n* `material` : A string containing the 16 hex encoded bytes of the key material.\n\n#### Output\n* `key_id` : The UUID of the imported key in SDKMS. Referred to in the other\noperations as `bdk_id`.\n\n### DUKPT Encrypt and Decrypt\n#### Input\n* `operation` : Either `encrypt` or `decrypt`, for encryption and decryption\nrespectively.\n* `bdk_id` : The UUID of the imported BDK key to use.\n* `ksn` : Key serial number, hex encoded.\n* `key_mode` : The method used for deriving the session key from the IPEK.\nPossible values are:\n- `datakey`\n- `pinkey`\n- `mackey`\n* `card_data` : The data to be encrypted or decrypted, encoded in a string in accordance with the encoding specified below.\n* `encoding` : For the `encrypt` operation this is the encoding of the data to be encrypted. For `decrypt`, this is the encoding that the data should be returned in.\nPossible values are:\n- `base64`\n- `hex`\n\n#### Output\n* `card_data` : The result of the encryption or decryption.\n\n## Example Usages\n### DUKPT Import\nImports a BDK into SDKMS for use with the other operations.\n\n#### Example Input\n```json\n{ \"operation\": \"import\",\n\"name\": \"my_bdk\",\n\"material\": \"0123456789ABCDEFFEDCBA9876543210\" }\n```\n\n#### Example Output\n```json\n{ \"key_id\": \"d17e7c0c-3246-41c4-9824-c98d2c6515fb\" }\n```\n\n### DUKPT Encrypt and Decrypt\nEncrypts or decrypts data with a key derived from the given BDK and KSN.\n\n#### Example Input\nBelow is a sample input json to the SDKMS DUKPT plugin's decrypt operation. The\nstructure is the same for encryption, though the semantics change slightly as\ndescribed above.\n```json\n{ \"operation\": \"decrypt\",\n\"bdk_id\": \"fd1fbe76-6d64-4d30-b351-e79449e1eb77\",\n\"ksn\": \"FFFF9876543210E00008\",\n\"key_mode\": \"datakey\",\n\"card_data\": \"y07Fue/gKW7x9yDM06LZBg==\",\n\"encoding\": \"base64\" }\n```\n\n#### Example Output\n```json\n{ \"card_data\": \"Zm9ydGFuaXg=\" }\n```\n\n## References\n\n* [https://github.com/dpjayasekara/node-dukpt](https://github.com/dpjayasekara/node-dukpt \"NodeJS DUKPT implementation\")\n* [https://github.com/sgbj/Dukpt.NET](https://github.com/sgbj/Dukpt.NET \"C# DUKPT implementation\")\n* [https://support.fortanix.com/sdkms/developers-guide-plugin.html](https://support.fortanix.com/sdkms/developers-guide-plugin.html \"SDKMS developers guide plugin\")\n* [https://support.fortanix.com/api/#/Plugins](https://support.fortanix.com/api/#/Plugins \"SDKMS plugins API\")\n\n### Release Notes\n- Initial Release", 
                "commit": "bdd8003e3d2601d72b5ddb2cd54b749c2e6f8cc0"
            }
        }
    }, 
    {
        "name": "X.509 CA", 
        "versions": {
            "1.0": {
                "path": "x509-ca/plugin.lua", 
                "description": "## Short Description\nIssue X.509 certificates for keys stored in SDKMS.\n\n### ## Introduction\nThe X.509 CA plugin allows SDKMS users to issue certificates for keys stored in SDKMS.\nThe plugin requires the CA key and certificate to be stored in SDKMS as well.\n\nOnce invoked, the plugin generates an X.509 certificate and returns the new certificate in PEM format encoded as a JSON string. To invoke the plugin, the user must specify the following as input to the plugin:\n\n- Subject's Distinguished Name (DN),\n- The name of the issuer certificate stored in SDKMS,\n- The name of the issuer key stored in SDKMS,\n- The name of the subject key stored in SDKMS,\n- The lifetime of the generated certificate in seconds.\n\nThe public key of the subject key will be included in the generated certificate.\nThe generated certificate will have a randomly generated serial number.\n\nNote that this plugin does not add limiting extensions, such as the key usage extension, to the generated certificate. It also does not ensure that the generated certificate is acceptable for any particular use case. For example, it allows the user to generate a certificate for `CN=domain1.com` while the issuer certificate is for `CN=domain2.net` which may not be acceptable. For more information about X.509 certificates see [RFC 5280](#rfc5280).\n\nAlso note that this plugin does not store the generated certificate in SDKMS and does not track generated certificates in any way, therefore, it does not prevent issuance of multiple certificates for the same subject.\n\n## Setup\nIn order to use this plugin, you need to generate or import your CA key and certificate in SDKMS. Additionally, you need to generate/import the subject key for each certificate you like to generate using this plugin.\nNote that the plugin needs to have access to these security objects in SDKMS. To ensure the plugin has access to these security objects, make sure that the plugin shares a group with each security object that it needs to access.\n\nHere is an example arrangement of objects in SDKMS:\n\n- Two groups: `X.509 CA` and `TLS Keys`,\n- The CA certificate (`x509 CA cert`) and CA key (`x509 CA key`) residing in group `X.509 CA`,\n- The subject key for an app that requires a certificate (`my app key`) residing in `TLS Keys`,\n- The X.509 CA plugin residing in both groups.\n\nThe example usage section shows how to invoke the plugin using the above setup to generate a certificate.\n\n## Input/Output\n\nThis plugin accepts a JSON object with the following fields as input:\n\n* `subject_dn`: a map of OIDs to values\n* `issuer_cert`: the name of the issuer cert security object\n* `issuer_key`: the name of the issuer key security object\n* `subject_key`: the name of the subject key security object\n* `cert_lifetime`: the lifetime of the certificate in seconds\n\nIt returns the newly generated certificate in PEM format encoded as a JSON string.\n\n\n## Example Usage\n\nAssuming the necessary objects are created as described in the example in the setup section, we can generate a certificate for `my app key` by invoking the plugin with the following input:\n\n```json\n{\n\"subject_dn\": {\n\"CN\": \"localhost\",\n\"OU\": \"Testing\"\n},\n\"subject_key\": \"my app key\",\n\"issuer_key\": \"x509 CA key\",\n\"issuer_cert\": \"x509 CA cert\",\n\"cert_lifetime\": 86400\n}\n```\n\nThe value for `cert_lifetime` in the example above is 24 hours expressed in seconds.\n\n\n## References\n- <a name=\"rfc5280\"></a>[RFC 5280](https://tools.ietf.org/html/rfc5280)\n\n\n### Release Notes\n- Initial release", 
                "commit": "bdd8003e3d2601d72b5ddb2cd54b749c2e6f8cc0"
            }
        }
    }, 
    {
        "name": "X.509 TBS CA", 
        "versions": {
            "1.0": {
                "path": "x509-tbs-ca/plugin.lua", 
                "description": "## Short Description\nCreates a signed X.509 Certificate structure for keys managed by SDKMS. It showcases the flexibility of the plugin framework to use user-specific data formats.\n\n### ## Introduction\nX.509 certificates are a key element of many security architectures. It cryptographically ties a public key to the issuer of the certificate. Companies may wish to use their own input format.\nThis example plugin shows the flexibility of Fortanix's plugin framework. In this case a basic JSON structure is accepted as input. After the input passes a user-specified verification function, any desired fields can be added and a valid X509 certificate is created. The signed certificate is returned  in PEM format.\n\n## Use Cases\n\nX.509 certificates are used in a wide variety of applications:\n\n- Webservers use X.509 certificates as part of TLS to authenticate their identity\n- IPsec uses it to authenticate peers\n- Code signing systems such as Microsoft Authenticate enable verification of vendors of computer programs\n\n## Input/Output JSON Object Format\n\nThe input is a JSON map with the following fields:\n\n* `subject_key`: the name of the key that will be included in the certificate\n* `issuer_cert`: the name of the issuer cert stored in SDKMS\n* `issuer_key`: the name of the issuer key stored in SDKMS\n* `cert_lifetime`: the lifetime of the certificate in seconds\n* `subject_dn`: a map of OIDs to values\n\n## Example Usages\n\n```\n{\n\"issuer_cert\": \"my CA cert\",\n\"issuer_key\": \"my CA key\",\n\"subject_key\": \"my server key\",\n\"cert_lifetime\": 86400,\n\"subject_dn\": { \"CN\": \"localhost\", \"OU\": \"Testing\" }\n}\n```\n\n## References\n\n- https://www.rfc-editor.org/rfc/rfc5280.txt\n\n### Release Notes\n- Initial release", 
                "commit": "bdd8003e3d2601d72b5ddb2cd54b749c2e6f8cc0"
            }
        }
    }, 
    {
        "name": "SSH CA", 
        "versions": {
            "1.0": {
                "path": "ssh-ca/plugin.lua", 
                "description": "## Short Description\nIssue certificates for SSH authentication\n\n### ## Introduction\nSSH certificates are a method for authenticating users and/or servers in the SSH protocol.\nInstead of bare public keys (the usual method of SSH authentication) an authority\nissues a certificate which can then be used to authenticate to an SSH server.\nSSH certificates were originally added to OpenSSH in version 5.6 (released in 2010).\n\n## Use Cases\n\nAuthenticate clients to servers or servers to clients using an trusted third party\nhosted on SDKMS.\n\n## Setup\n\n### Creating CA key with SDKMS\n\nThe initial step is to create a key for the SSH CA. Generate an RSA\nkey with suitable parameters on SDKMS, and then download the public key.\n\nConverting the public to the OpenSSH format requires a two-step process.\nFirst, use OpenSSL to convert the RSA key to \"RSAPublicKey\" format:\n\n`$ openssl rsa -pubin -RSAPublicKey_out -in sdkms_rsa.pub > sdkms_rsa_conv.pem`\n\nThen use `ssh-keygen` to convert this to the SSH format\n\n`$ ssh-keygen -m PEM -i -f sdkms_rsa_conv.pem > ssh_ca.pub`\n\n### Creating CA key with OpenSSH\n\nAlternatively, the key can be created on a trusted machine using OpenSSH\ntools, then transferred to SDKMS:\n\n`$ ssh-keygen -f ssh_ca`\n\nThis will create two files, `ssh_ca.pub` (public key in SSH format)\nand `ssh_ca` (private key in PKCS #8 format).\n\n```\n-----BEGIN RSA PRIVATE KEY-----\nMIIEpAI...\n-----END RSA PRIVATE KEY-----\n```\n\nTo import the SSH private key in SDKMS, copy the base64 encoded block\n(but *not* the PEM headers starting with \"-----\") and paste it into\nthe Security Object import field. Make sure Sign and Verify operations\nare enabled. Disable Export unless required.\n\n### Server Configuration\n\nSet up sshd configuration for accepting SSH certificates. In your `sshd_config` add\n\n`TrustedUserCAKeys /path/to/ssh_ca.pub`\n\nand restart `sshd`\n\n### Issue Client Cert\n\nGenerate an RSA key pair that the user will use:\n\n`ssh-keygen -f ~/.ssh/user_key`\n\nThis will again generate two keys, `user_key` (PKCS#8 private key) and\n`user_key.pub` (the SSH format public key). The `user_key.pub` should look like\n\n`ssh-rsa AAAAB3<more base64 data> username@hostname`\n\n## Input/Output JSON\n\n```\n{\n\"cert_lifetime\":<integer>,\n\"valid_principals\":\"<username>\",\n\"cert_type\":\"user\",\n\"ca_key\":\"<sobject name>\",\n\"extensions\":{<map of strings to strings>},\n\"critical_extensions\":{<map of strings to strings>},\n\"pubkey\":\"<string>\"\n}\n```\n\n\"`cert_lifetime`\" specifies the lifetime of the certificate in seconds.\n\n\"`valid_principals`\" specifies what username this certificate can be used for.\n\n\"`cert_type`\" can be \"user\" or \"server\".\n\n\"`ca_key`\" gives the name of the private key that was used when the RSA key was\nimported into SDKMS earlier.\n\n\"`extensions`\" specifies operations the certificate can be used for. Values\nOpenSSH supports include \"`permit-X11-forwarding`\", \"`permit-agent-forwarding`\"\n\"`permit-port-forwarding`\", \"`permit-pty`\", and \"`permit-user-rc`\". In theory,\nextensions can take values, but all currently defined extensions use an empty\nstring. Unknown values will be ignored by the server.\n\n\"`critical_extensions`\" specifies operations which if the server does not\nunderstand the value, then the login attempt will be rejected. The values OpenSSH\nsupports are \"`force-command`\" and \"`source-address`\". \"`force-command`\" specifies a\nsingle command which the certificate can be used for. \"`source-address`\" gives a\nlist of host/mask pairs, login is only allowed from an IP matching one of the\nlisted values.\n\n\"`pubkey`\" gives the contents of the `user_key.pub` file with the leading \"`ssh-rsa `\" and\ntrailing \"` username@hostname`\" removed.\n\n## Example Usage\n\n```\n{\n\"cert_lifetime\":86400,\n\"valid_principals\":\"desired_username\",\n\"cert_type\":\"user\",\n\"ca_key\":\"SSH CA Key\",\n\"extensions\":{\"permit-pty\":\"\"},\n\"critical_extensions\":{\"source-address\":\"10.2.0.0/16,127.0.0.1\"},\n\"pubkey\":\"AAAAB3<more base64 data>\"}\n}\n```\n\nWhen the plugin is invoked it will return a string that looks like\n\n`\"ssh-rsa-cert-v01@openssh.com AAAAHHNza....\"`\n\nCopy the entire contents to `~/.ssh/user_key-cert.pub`\n\nNow test the output using `ssh-keygen`:\n\n```\n$ ssh-keygen -L  -f user_key-cert.pub\nuser_key-cert.pub:\nType: ssh-rsa-cert-v01@openssh.com user certificate\n...\n```\n\nNow run\n\n`$ ssh -i ~/.ssh/user_key server_host whoami`\n\nThe login should succeed with the command executed on the remote host.\n\nIf you use `-v` option when using a certificate you should see something like\n\n```\ndebug1: Offering public key: RSA-CERT SHA256:Hcb9trzeAptUdTgqWj9VEncbkAGOpAglGnUrYGq4/Vo user_key\ndebug1: Server accepts key: pkalg ssh-rsa-cert-v01@openssh.com blen 1029\n```\n\n## References\n\nhttps://cvsweb.openbsd.org/src/usr.bin/ssh/PROTOCOL.certkeys?annotate=HEAD\n\n### Release Notes\n\nInitial release", 
                "commit": "bdd8003e3d2601d72b5ddb2cd54b749c2e6f8cc0"
            }
        }
    }, 
    {
        "name": "HD Wallet", 
        "versions": {
            "1.0": {
                "path": "hd-wallet/plugin.lua", 
                "description": "## Short Description\nThis plugin implements hierarchical deterministic wallets (or \"HD Wallets\") BIP0032 protocol.\n\n### ## Introduction\nThe plugin allows to derive child key (xprv, xpub) from a master key in a deterministic way, and/or sign transaction hashes for UTXO and ethereum type crypto coin.\n\n## Use cases\n\nThe plugin can be used to\n\n- Derive child key for UTXO\n- Derive child key for ethereum\n- Sign transaction for UTXO\n- Sign transaction for ethereum\n\n## Setup\n\n- Generate HD-Wallets master key manually\n**Example Master Key:** `xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U`\n- Importe master key in SDKMS as secret raw key\n\n## Input/Output JSON object format\n\n**Input**\n\n```\n{\n\"master_key_id\": \"<Master-Key-UUID>\",\n\"path\": \"<Child-Key-Path>\"  ,\n\"msg_hash\": \"<32-Byte-Message-Hash>\",\n\"coin\": \"<Coin-Type>\"\n}\n```\n\n**Output**\n\n```\n\"xprv\": \"<HD-Wallet-Private-Key>\",\n\"xpub\": \"<HD-Wallet-Public-Key>\",\n\"coin_signature\": \"<Bitcoin-canonicalized-ECDSA-signature>\",\n\"signature\": \"<ECDSA signature>\"\n```\n\n* `master_key_id`: UUID of master key imported in SDKMS\n* `path`: Path of key to be derived to sign e.g: m/0, m/1, m/2/10 etc\n* `msg_hash`: 32 byte SHA-3 message hash\n* `coin`: coin type utxo or eth\n* `xprv`: BIP0032 private key\n* `xpub`: BIP0032 public key\n* `coin_signature`: Bitcoin canonicalized ECDSA signature\n* `signature`: ECDSA signature\n\n## Example Input/Output JSON object\n\n**Input JSON object**\n\n```\n{\n\"master_key_id\": \"0eae8ff0-553e-4f47-bb64-7c87f34bf5e5\",\n\"coin\": \"utxo\",\n\"path\": \"m/2\",\n\"msg_hash\": \"45a0ee821b05400f513891bbb567a99139f3df72e9e1d4b48186841cc5996d2f\"\n}\n```\n\n**Output JSON object**\n\n```\n{\n\"xprv\": \"xprv9uZghWCSYwDho7us3q1WLBjVYx2xzVJNT8qNo4P9i8wa3tQJYbffzztTF6wXjuorG49NXahqraWsrVUmy3uTJLkvSYXyDLnHHU1GJibUk2t\",\n\"xpub\": \"xpub68Z371jLPJn11bzL9rYWhKgE6ysTPx2DpMkybSnmGUUYvgjT68yvYoCw6PP8Vo7YoZRC6iqrfpixEUG694KgHPYYnydGuEYDwjESStYxYxe\",\n\"signature\": \"3045022100af9bf94c4959328b56861ca5f175b5e59014cb5bd2a5fcee2e95b1563dbc652e0220411ff01751af64d6b7209908fc58f527b07a0a9258eee7be7aa5704136954b02\",\n\"coin_signature\": \"af9bf94c4959328b56861ca5f175b5e59014cb5bd2a5fcee2e95b1563dbc652e411ff01751af64d6b7209908fc58f527b07a0a9258eee7be7aa5704136954b02\"\n}\n```\n\n## References\n\n- https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n\n### Release Notes\n- Initial release", 
                "commit": "bdd8003e3d2601d72b5ddb2cd54b749c2e6f8cc0"
            }
        }
    }, 
    {
        "name": "JWS+JWE Decrypt", 
        "versions": {
            "1.0": {
                "path": "jws-jwe-decrypt/plugin.lua", 
                "description": "## Short Description\nGenerates the user's payload from a **JSON Web Encryption (JWE)** .\n\n### ## Introduction\nThis plugin performs decrypt using JWE standards:  `enc:  A256CBC-HS512 alg:  RSA-OAEP-256`.\n\nIt performs the following steps:\n\n1. It takes the JWE as input and splits it to get the parts i.e. encrypted key material, iv, ciphertext, and tag.\n2. Decrypts the encrypted composite transient key using the RSA private key (provided in input), and generate AES, HMAC transient keys from the decrypted key-material.\n3. Computes the `aad` from the header in the input and `al` to store the size of `aad`.\n4. Using `iv` from the input, and the generated AES key, it decrypts the cipher provided in the input in `CBC` mode. We receive the plaintext after decryption, which is correct only after the verification is successful.\n5. For verification, it creates an input payload for HMAC consisting of `aad, iv, cipher, al`.\n6. Creates a HMAC of the payload created above using HMAC key using `SHA-512` as the hashing algorithm.\n7. It truncates the digest generated above to half the length and compares it to the tag in the input.\n8. If the generated digest matches the tag, then it verifies the plaintext which is a JWS.\n9. It takes the JWS and splits it to get the parts i.e. header, payload, and signature.\n10. From the header and payload, it re-constructs the `Jws Signing input`.\n11. Decodes the signature from Base64URL to Base64, so as to use for verifying the signature.\n12. Imports the `certificate` as a transient key.\n13. Verifies the above constructed `Jws Signing input` and the decoded `signature` by `certificate` using `SHA-256` and mode as `PKCS1-v1_5`.\n14. The plugin output is `VERIFIED` and the actual `payload` (inside the JWS) in case signature is correctly verified and `VERIFICATION FAILED` otherwise.\n\n## Use cases\n\n1. Assert one\u2019s identity, given that the recipient of the JWE trusts the asserting party.\n2. Transfer data securely between interested parties over a unsecured channel.\n\n## Setup\n\n1. For these plugin, we need a RSA private key already imported in SDKMS, and its corresponding public key as a certificate which the user should provide as input.\n\n## Input/Output JSON object format\n\nInput parameters details:\n\n1. **`jwe`** corresponds to JWE generated by `Encrypt` plugin.\n2. **`key`** is the name of `RSA` private key which should be already imported in `SDKMS`. This is used for decrypting the payload.\n3. **`cert`** contains the contents of the certificate (`pem` file) in base64 encoding. This is used to verify the signature.\n\n## Example usages\n\nSample Input format: (The certificate value should be provided as a base-64 encoded string).\n```\n{\n\"jwe\": \"...\",\n\"key\" : \"keyname\",\n\"cert\" : \"...\"\n}\n```\n\nSample output format:\n```\n{\n\"payload\": \"...\",\n\"output\": \"VERIFIED\"\n}\n```\n\n## References\n\n1. https://tools.ietf.org/html/rfc7515\n2. https://tools.ietf.org/html/rfc7516\n\n### Release Notes\n- Initial release", 
                "commit": "bdd8003e3d2601d72b5ddb2cd54b749c2e6f8cc0"
            }
        }
    }, 
    {
        "name": "Key/Value Pair", 
        "versions": {
            "1.0": {
                "path": "kvp/plugin.lua", 
                "description": "## Short Description\nSeamlessley extend the functionality of Fortanix Self Defending KMS Secrets. Leverage applications generate and manage key-value (KV) pairs through Self Defending KMS Secrets.\n\n### ## Introduction\nEvery day, application teams come to rely on numerous secrets in their development and operational (DevOps) processes. Secrets ranging from passwords, tokens, certificates, SSH keys and database credentials simply cannot be hard-coded or statically configured.\n\n**Fortanix Self Defending KMS is THE MOST SECURE KMS** in the market. With this Plugin, DevOps can now easily manage their build and deployment secrets to maintain confidentiality throughout their CI/CD pipelines as well as during application runtime.\n\n### Use cases\n\n* Set and retrieve keys and corresponding values\n- keys and values are comma-separated parameters inside JSON\n\n* Namespace support prevents secret path collisions\n- names of Self Defending KMS Secrets are unique within an Self Defending KMS Account\n- Plugin prefixes KV secrets paths with a namespace to allow path reuse\n- allows multiple secrets with the same path inside an Self Defending KMS Account\n\n* Versioning support for keys such that:\n- Key update/delete automatically creates a new version\n- Key update/delete does not delete other keys\n- Uses Self Defending KMS custom metadata to validate versions\n\n* Deletion truncates the latest version (LIFO) or purges all versions\n\n## Setup and Usage\n### Invoking Plugins from Self Defending KMS CLI\nCheck the Self Defending KMS Python-based CLI README for information on setting up the CLI.\n\n* Log in to Self Defending KMS first.  `$ sdkms-cli user-login`\n- Currently, the CLI only allows `user-login` for Plugin invocation.\n- Specify an account argument if user has access to multiple accounts:\n- `--account-name`\n* Invoke the Plugin:\n`$ sdkms-cli invoke-Plugin --name kvp --in <read-secret-kvp.json>`\n- Either of the following argument should work:\n- `--name`\n- `--id`\n- `in` : Path to input JSON file.\n\n\n## Input and Output JSON Formats\nThe following sections specify the fields in the inputs and outputs of the\nPlugin's operations, which are JSON maps.\n\n__Important note__ about some of the input JSON parameters:\n\n* `group` : string, the prefix of the KVP secret.\n- Can be some arbitrary namespace label or an Self Defending KMS Group UUID.\n- In case a Group UUID is specified, KVP secret creation will be attempted in that Group.\n- The Plugin also needs to be a member of the specified Self Defending KMS Group.\n* `path` : string, the label of the KVP secret.\n- If `group` isn't specified, then the path needs to be unique within the entire Self Defending KMS Account.\n\n\n###  GET Operation\n#### Input\n* `op` : string, must be = `get` for reading a specific KVP secret.\n* `group` : string, the prefix of the KVP secret. ***Optional***.\n* `path` : string, the label of the KVP secret. **Required**\n* `version` : string, version of the KVP secret. ***Optional***.\n* `keys` : string, comma-separated list of key labels. ***Optional***.\n\n#### Output\n* `v#` : string, version number of the KVP secret.\n* [array] containing all key-value pairs or those matching the input keys, if specified:\n- `<key_name>`: string, JSON record index.\n- `<key_value>`: string, JSON record value.\n\n### PUT Operation\n#### Input\n* `op` : string, must be = `put` for writing a specific KVP secret.\n* `group` : string, the prefix of the KVP secret. ***Optional***.\n* `path` : string, the label of the KVP secret. **Required**\n* `keys` : string, comma-separated list of key labels. **Required**.\n* `values` : string, a comma-separated list of key values. **Required**.\n\n#### Output\n* `v#` : string, the version number of the KVP secret. **Auto-incremented**.\n* [array] containing all key-value pairs that match the input keys as well as those preexisting :\n- `<key_name>`: string, JSON record index.\n- `<key_value>`: string, JSON record value.\n\n### DEL Operation\n#### Input\n* `op` : string, must be = `put` for dropping a key within a specific KVP secret.\n* `group` : string, the prefix of the KVP secret. ***Optional***.\n* `path` : string, the label of the KVP secret. **Required**\n* `keys` : string, comma-separated list of key labels. **Required**.\n\n#### Output\n* `v#` : string, the version number of the KVP secret. **Auto-incremented**.\n* [array] containing all key-value pairs excluding the keys specified:\n- `<key_name>`: string, JSON record index.\n- `<key_value>`: string, JSON record value.\n\n### DEBUG Operation\n#### Input\n* `op` : string, must be = `debug` for displaying all the versions of a specific KVP secret.\n* `group` : string, the prefix of the KVP secret. ***Optional***.\n* `path` : string, the label of the KVP secret. **Required**\n* `keys` : string, comma-separated list of key labels. ***Optional***.\n\n#### Output\n*  [array] containing **all versions** of the KVP secret:\n- `v#` : string, the version number of the KVP secret.\n* [array] containing all key-value pairs excluding the keys specified :\n- `<key_name>`: string, JSON record index.\n- `<key_value>`: string, JSON record value.\n\n### TERMINATE Operation\n__Note__: All versions are deleted and the operation is audited.\n#### Input\n* `op` : string, must be = `ter` for completely destroying a specific KVP secret.\n* `group` : string, the prefix of the KVP secret. ***Optional***.\n* `path` : string, the label of the KVP secret. **Required**\n\n#### Output\n*  `message`: [string] error or success.\n\n## Testing\n\nFollowing example shows the lifecycle of a KVP secret as each operation is performed through the KVP Plugin.\n\n* `op:put` creates new key(s)\n- Version: new >> v1\n- Input: `{op:put, [k1], [val1]}`\n- Output: `v1{[k1:val1]}`\n* `op:put` updates and/or adds new key(s)\n- Version: v1 >> v2\n- Input `{op:put, keys:k1,k2, values:v1,v2}`\n- Output: `v2{[k1:v1,k2:v2]}`\n* `op:del` removes a key and bumps up version\n- Version: v2 >> v3\n- Input: `{op:del, keys: k2}`\n- Output: `v3{[k1:v1]}`\n* `op:put` increments always version\n- Version: v3 >> v4\n- Input: `{op:put, keys:k3, values:val3}`\n- Output: `v4{[k1:v1,k3:val3]}`\n* `op:debug` returns all versions and filters by key(s)\n- Versions: v1 <<>> v4:\n- Input: `{op:debug, keys:k1}`\n- Output: `v1{[k1:val1]}, v2([k1:v1]}, v3{[k1:v1]}, v4{[k1:v1]}`\n* `op:ter`destroys the KV secret altogether\n- Versions: `{[v4,v3,v2,v1]}` >> destroyed\n- Output: error or success message\n\n\n## Room for Improvement\nFollowing use cases are not supported yet:\n\n* alternative storage to Self Defending KMS Opaque Security Objects\n* explicit auditing with fine-grained levels\n* deletion of specific version and linking adjacent versions\n* revert to version and truncate all future version\n\nCommunity improvements are welcome. Join us on [Slack](https://fortanix.com/community/).\nGet your **API KEY** by signing up at [sdkms.fortanix.com](https://sdkms.fortanix.com).\n\n## References\n* [support.fortanix.com/sdkms/developers-guide-Plugin.html](https://support.fortanix.com/sdkms/developers-guide-Plugin.html \"Self Defending KMS developers guide Plugin\")\n* [support.fortanix.com/api/#/Plugins](https://support.fortanix.com/api/#/Plugins \"Self Defending KMS Plugins API\")\n* [bitbucket.org/fortanix/kubernetes-integration](https://bitbucket.org/fortanix/kubernetes-integration \"Kubernetes Integration\")\n\n### Release Notes\n- Initial Release\n- Uses Self Defending KMS Secret Security Object\n- Self Defending KMS Secrets are fully audited\n- Storage of KVPs limited to 1024 bytes\n- Test script provided\n- Tested with **Kubernetes Secrets Injection** referenced above.", 
                "commit": "bdd8003e3d2601d72b5ddb2cd54b749c2e6f8cc0"
            }
        }
    }, 
    {
        "name": "JWS+JWE Encrypt", 
        "versions": {
            "1.0": {
                "path": "jws-jwe-encrypt/plugin.lua", 
                "description": "## Short Description\nThis plugin generates a **JSON Web Encryption (JWE)** from the **JSON Web Signature (JWS)**, which is constructed using the user's input payload.\n\n### ## Introduction\nThis plugin, performs encrypt using JWE standards:  enc:  A256CBC-HS512 alg:  RSA-OAEP-256.\n\nThis plugin performs the following steps:\n\n1. It generates a JWS from the `payload`.\n2. Generates a header for JWS containing `alg` and `typ`, as:\n```\n{typ : \"JWT\", \"alg\" : \"RS256\"}\n```\n3. Encodes header and input payload to the Base64URL format.\n4. Constructs the JWS Signing input by concatenating header and payload.\n5. Sign the above constructed `Jws Signing input` by RSA private key (provided in input) using SHA-256 and mode as PKCS1-v1_5.\n6. Encodes the signature in the Base64URL format and constructs JWS by concatenating header, payload, and signature by using `\".\"` as a separator. It will use this `jws` as input payload to `JWE`.\n7. Generate the header for JWE, containing `alg, enc, typ`.\n```\n{alg = \"RSA-OAEP-256\", enc = \"A256CBC-HS512\", typ = \"JWT\"}\n```\n8. Generate an exportable `transient` `AES` key of size `256` bits and an exportable `transient` `HMAC` key of size `256` bits.\n9. Encrypts the above generated JWS using the transient AES key in `CBC` mode.\n10. Generate `aad` using the `header` and `al` to store the size of `aad`.\n11. Creates an input payload for HMAC consisting of `aad, iv, cipher, al`.\n12. Creates a HMAC of the payload created above using HMAC key using `SHA-512` as the hashing algorithm.\n13. Truncate the digest generated above to half the length and use as authentication-tag.\n14. Import the `certificate` as a transient key.\n15. Encrypt the combined transient AES key and HMAC key with the `certificate` given as input, using `OAEP_MGF1_SHA256` as the mode and `RSA` is the algorithm.\n16. Returns the header, encrypted transient key, encrypted input payload, iv (used for encrypting input payload), the authentication-tag and JWE.\n\n## Use cases\n\n1. Assert one\u2019s identity, given that the recipient of the JWE trusts the asserting party.\n2. Transfer data securely between interested parties over a unsecured channel.\n\n## Setup\n\n1. For these plugin, we need a RSA private key already imported in SDKMS, and its corresponding public key as a certificate which the user should provide as input.\n\n## Input/Output JSON object format\n\n1. **`payload`** corresponds to input data, which is first signed and then encrypted.\n2. **`key`** is the name of `RSA` private key which should be already imported in `SDKMS`. This is used for signing the payload.\n3. **`cert`** contains the contents of the certificate (`pem` file) in base64 encoding. This is used to encrypt and verify the signature.\n\n## Example usages\n\nSample Input format: (The certificate value should be supplied as base64 encoded string)\n```\n{\n\"payload\" : \"hello world\",\n\"key\" : \"keyname\",\n\"cert\" : \"....\"\n}\n```\n\nSample Output format:\n```\n{\nheader : header,\nencrypted_key : encrypt_trans_key,\ncipher : cipher,\niv : iv,\ntag : digest,\njwe : jwe,\n}\n```\n\n## References\n\n1. https://tools.ietf.org/html/rfc7515\n2. https://tools.ietf.org/html/rfc7516\n\n### Release Notes\n- Initial release", 
                "commit": "bdd8003e3d2601d72b5ddb2cd54b749c2e6f8cc0"
            }
        }
    }
]